<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>siplasplas: cpp::SignalEmitter Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">siplasplas
   </div>
   <div id="projectbrief">A library for C++ reflection and introspection</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classcpp_1_1_signal_emitter.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classcpp_1_1_signal_emitter-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">cpp::SignalEmitter Class Reference<div class="ingroups"><a class="el" href="group__signals.html">Signals</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Class that can send and receive signals from other emitters.  
 <a href="classcpp_1_1_signal_emitter.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="emitter_8hpp_source.html">siplasplas/signals/emitter.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for cpp::SignalEmitter:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classcpp_1_1_signal_emitter.png" usemap="#cpp::SignalEmitter_map" alt=""/>
  <map id="cpp::SignalEmitter_map" name="cpp::SignalEmitter_map">
<area href="classcpp_1_1_c_make_project.html" title="Configures and builds an existing CMake project. " alt="cpp::CMakeProject" shape="rect" coords="0,56,145,80"/>
<area href="classcpp_1_1_c_make_target.html" title="Represents a CMake target being watched by a project. " alt="cpp::CMakeTarget" shape="rect" coords="155,56,300,80"/>
<area href="classcpp_1_1_file_system_listener.html" title="File system listener class that notifies filesystem changed through signals. " alt="cpp::FileSystemListener" shape="rect" coords="310,56,455,80"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af3d2b9b70a5ca44986c698a6b77c1c7f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af3d2b9b70a5ca44986c698a6b77c1c7f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SignalEmitter</b> (<a class="el" href="classcpp_1_1_signal_emitter.html">SignalEmitter</a> &amp;&amp;)=default</td></tr>
<tr class="separator:af3d2b9b70a5ca44986c698a6b77c1c7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35c7746eb087c35be97101df76f432e5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a35c7746eb087c35be97101df76f432e5"></a>
<a class="el" href="classcpp_1_1_signal_emitter.html">SignalEmitter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classcpp_1_1_signal_emitter.html">SignalEmitter</a> &amp;&amp;)=default</td></tr>
<tr class="separator:a35c7746eb087c35be97101df76f432e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c933986daab2d4ce95b3f92adfe0970"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpp_1_1_signal_emitter.html#a2c933986daab2d4ce95b3f92adfe0970">poll</a> ()</td></tr>
<tr class="memdesc:a2c933986daab2d4ce95b3f92adfe0970"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polls this object for incomming signal emissions.  <a href="#a2c933986daab2d4ce95b3f92adfe0970">More...</a><br /></td></tr>
<tr class="separator:a2c933986daab2d4ce95b3f92adfe0970"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a066ef1c17fd4550eed4bb11436af3e33"><td class="memTemplParams" colspan="2">template&lt;typename Caller , typename Function , typename R , typename Class , typename... Args&gt; </td></tr>
<tr class="memitem:a066ef1c17fd4550eed4bb11436af3e33"><td class="memTemplItemLeft" align="right" valign="top">static std::shared_ptr&lt; const <a class="el" href="classcpp_1_1_signal_sink.html">SignalSink</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcpp_1_1_signal_emitter.html#a066ef1c17fd4550eed4bb11436af3e33">connect</a> (Caller &amp;caller, R(Class::*source)(Args...), Function function)</td></tr>
<tr class="memdesc:a066ef1c17fd4550eed4bb11436af3e33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a direct connection from the given emitter object to the given function.  <a href="#a066ef1c17fd4550eed4bb11436af3e33">More...</a><br /></td></tr>
<tr class="separator:a066ef1c17fd4550eed4bb11436af3e33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8519d6b9541fd06c16707649bed4c446"><td class="memTemplParams" colspan="2">template&lt;typename Caller , typename Callee , typename Function , typename R , typename Class , typename... Args&gt; </td></tr>
<tr class="memitem:a8519d6b9541fd06c16707649bed4c446"><td class="memTemplItemLeft" align="right" valign="top">static std::shared_ptr&lt; const <a class="el" href="classcpp_1_1_signal_sink.html">SignalSink</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcpp_1_1_signal_emitter.html#a8519d6b9541fd06c16707649bed4c446">connect</a> (Caller &amp;caller, R(Class::*source)(Args...), Callee &amp;callee, Function function)</td></tr>
<tr class="memdesc:a8519d6b9541fd06c16707649bed4c446"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a direct connection from the given emitter object to the given function, using an specific callee object.  <a href="#a8519d6b9541fd06c16707649bed4c446">More...</a><br /></td></tr>
<tr class="separator:a8519d6b9541fd06c16707649bed4c446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a154d13b2bcf5f8bbf997b5172284b486"><td class="memTemplParams" colspan="2">template&lt;typename Caller , typename Function , typename R , typename Class , typename... Args&gt; </td></tr>
<tr class="memitem:a154d13b2bcf5f8bbf997b5172284b486"><td class="memTemplItemLeft" align="right" valign="top">static std::shared_ptr&lt; const <a class="el" href="classcpp_1_1_signal_sink.html">SignalSink</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcpp_1_1_signal_emitter.html#a154d13b2bcf5f8bbf997b5172284b486">connect_async</a> (Caller &amp;caller, R(Class::*source)(Args...), Function function)</td></tr>
<tr class="memdesc:a154d13b2bcf5f8bbf997b5172284b486"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an asynchronous connection between a signal and a function.  <a href="#a154d13b2bcf5f8bbf997b5172284b486">More...</a><br /></td></tr>
<tr class="separator:a154d13b2bcf5f8bbf997b5172284b486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74547169c5a7375e9812e966efb2d3fd"><td class="memTemplParams" colspan="2">template&lt;typename Caller , typename Callee , typename Function , typename R , typename Class , typename... Args&gt; </td></tr>
<tr class="memitem:a74547169c5a7375e9812e966efb2d3fd"><td class="memTemplItemLeft" align="right" valign="top">static std::shared_ptr&lt; const <a class="el" href="classcpp_1_1_signal_sink.html">SignalSink</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcpp_1_1_signal_emitter.html#a74547169c5a7375e9812e966efb2d3fd">connect_async</a> (Caller &amp;caller, R(Class::*source)(Args...), Callee &amp;callee, Function function)</td></tr>
<tr class="memdesc:a74547169c5a7375e9812e966efb2d3fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an asynchronous connection between a signal and a function using an specific callee object.  <a href="#a74547169c5a7375e9812e966efb2d3fd">More...</a><br /></td></tr>
<tr class="separator:a74547169c5a7375e9812e966efb2d3fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21d269a77bf062806761307531625f52"><td class="memTemplParams" colspan="2">template&lt;typename Caller , typename Callee , typename R , typename... Args&gt; </td></tr>
<tr class="memitem:a21d269a77bf062806761307531625f52"><td class="memTemplItemLeft" align="right" valign="top">static std::shared_ptr&lt; const <a class="el" href="classcpp_1_1_signal_sink.html">SignalSink</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcpp_1_1_signal_emitter.html#a21d269a77bf062806761307531625f52">bypass</a> (Caller &amp;caller, R(Caller::*source)(Args...), Callee &amp;callee, R(Callee::*dest)(Args...))</td></tr>
<tr class="memdesc:a21d269a77bf062806761307531625f52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connects two signals synchronously.  <a href="#a21d269a77bf062806761307531625f52">More...</a><br /></td></tr>
<tr class="separator:a21d269a77bf062806761307531625f52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ccfedff687cca06895674a6dacaf55b"><td class="memTemplParams" colspan="2">template&lt;typename Caller , typename Callee , typename R , typename... Args&gt; </td></tr>
<tr class="memitem:a0ccfedff687cca06895674a6dacaf55b"><td class="memTemplItemLeft" align="right" valign="top">static std::shared_ptr&lt; const <a class="el" href="classcpp_1_1_signal_sink.html">SignalSink</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcpp_1_1_signal_emitter.html#a0ccfedff687cca06895674a6dacaf55b">bypass_async</a> (Caller &amp;caller, R(Caller::*source)(Args...), Callee &amp;callee, R(Callee::*dest)(Args...))</td></tr>
<tr class="memdesc:a0ccfedff687cca06895674a6dacaf55b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connects two signals asynchronously.  <a href="#a0ccfedff687cca06895674a6dacaf55b">More...</a><br /></td></tr>
<tr class="separator:a0ccfedff687cca06895674a6dacaf55b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a037c3bfe62b4cb68df612fd413321e98"><td class="memTemplParams" colspan="2">template&lt;typename Class , typename R , typename... FArgs, typename... Args&gt; </td></tr>
<tr class="memitem:a037c3bfe62b4cb68df612fd413321e98"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcpp_1_1_signal_emitter.html#a037c3bfe62b4cb68df612fd413321e98">emit</a> (Class &amp;emitter, R(Class::*function)(FArgs...), Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a037c3bfe62b4cb68df612fd413321e98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emits a signal on the given emitter.  <a href="#a037c3bfe62b4cb68df612fd413321e98">More...</a><br /></td></tr>
<tr class="separator:a037c3bfe62b4cb68df612fd413321e98"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a2b7620b3a756bc26379fa45ac423d3b4"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2b7620b3a756bc26379fa45ac423d3b4"></a>
template&lt;typename Function , typename... Args&gt; </td></tr>
<tr class="memitem:a2b7620b3a756bc26379fa45ac423d3b4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>invoke</b> (Function function, Args &amp;&amp;...args)</td></tr>
<tr class="separator:a2b7620b3a756bc26379fa45ac423d3b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class that can send and receive signals from other emitters. </p>
<p>This class manages mapping from signals to sinks (i.e. outgoing connectiong from this object) as well as incomming connections. All connections are closed when the caller (source object) or the callee (destination object, if there is) are destroyed.</p>
<p>For details </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__signals.html" title="A simple multi-threaded message passing system. ">Signals</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="cmake_2cmake-project_8cpp-example.html#_a0">cmake/cmake-project.cpp</a>.</dd>
</dl></div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a21d269a77bf062806761307531625f52"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Caller , typename Callee , typename R , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt;const <a class="el" href="classcpp_1_1_signal_sink.html">SignalSink</a>&gt; cpp::SignalEmitter::bypass </td>
          <td>(</td>
          <td class="paramtype">Caller &amp;&#160;</td>
          <td class="paramname"><em>caller</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(Caller::*)(Args...)&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callee &amp;&#160;</td>
          <td class="paramname"><em>callee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(Callee::*)(Args...)&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Connects two signals synchronously. </p>
<p>This connection bypasses signals so there's no need to have an intermediary sink to link one signal to another. The connection is synchronous, so when the source signal is emitted, the destination signal is emitted directly, in the same thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">caller</td><td>Emitter of the source signal. </td></tr>
    <tr><td class="paramname">Caller::*source</td><td>Source signal. </td></tr>
    <tr><td class="paramname">callee</td><td>Emitter of the destination signal. Could be the caller too. </td></tr>
    <tr><td class="paramname">Callee::*dest</td><td>Destination signal.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to the SYncSink implementing the connection. </dd></dl>

</div>
</div>
<a class="anchor" id="a0ccfedff687cca06895674a6dacaf55b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Caller , typename Callee , typename R , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt;const <a class="el" href="classcpp_1_1_signal_sink.html">SignalSink</a>&gt; cpp::SignalEmitter::bypass_async </td>
          <td>(</td>
          <td class="paramtype">Caller &amp;&#160;</td>
          <td class="paramname"><em>caller</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(Caller::*)(Args...)&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callee &amp;&#160;</td>
          <td class="paramname"><em>callee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(Callee::*)(Args...)&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Connects two signals asynchronously. </p>
<p>This connection bypasses signals so there's no need to have an intermediary sink to link one signal to another. The destination signal is invoked whenever the callee object is polled. The destination signal is emitted from the thread the callee ofject is polled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">caller</td><td>Emitter of the source signal. </td></tr>
    <tr><td class="paramname">Caller::*source</td><td>Source signal. </td></tr>
    <tr><td class="paramname">callee</td><td>Emitter of the destination signal. Could be the caller too. </td></tr>
    <tr><td class="paramname">Callee::*dest</td><td>Destination signal.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to the SYncSink implementing the connection. </dd></dl>

</div>
</div>
<a class="anchor" id="a066ef1c17fd4550eed4bb11436af3e33"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Caller , typename Function , typename R , typename Class , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt;const <a class="el" href="classcpp_1_1_signal_sink.html">SignalSink</a>&gt; cpp::SignalEmitter::connect </td>
          <td>(</td>
          <td class="paramtype">Caller &amp;&#160;</td>
          <td class="paramname"><em>caller</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(Class::*)(Args...)&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function&#160;</td>
          <td class="paramname"><em>function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a direct connection from the given emitter object to the given function. </p>
<p>Direct connections invoke the destination function just after the source signal is invoked. The destination function is invoked in the same thread the signal was emitted. This connections preserve caller affinity (The sink is invoked only if it was the caller object was who emitted the signal, not whenever any object emits the signal). Direct connections are implemented by registering instances of <a class="el" href="classcpp_1_1_sync_sink.html" title="Implements a direct connection to the destination function. ">SyncSink</a> on the caller object. The connection has no associated callee object, so there's no way to poll this connection except from the returned sink. Both source (The member function pointer representing the signal) and function must have the same signature.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">caller</td><td>object the signal is raised from. </td></tr>
    <tr><td class="paramname">Class::*source</td><td>Pointer to the class member function representing the signal. </td></tr>
    <tr><td class="paramname">function</td><td>Function to be invoked when the signal is emitted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to the sink of the connection. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="fswatch_2fswatch_8cpp-example.html#a1">fswatch/fswatch.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a8519d6b9541fd06c16707649bed4c446"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Caller , typename Callee , typename Function , typename R , typename Class , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt;const <a class="el" href="classcpp_1_1_signal_sink.html">SignalSink</a>&gt; cpp::SignalEmitter::connect </td>
          <td>(</td>
          <td class="paramtype">Caller &amp;&#160;</td>
          <td class="paramname"><em>caller</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(Class::*)(Args...)&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callee &amp;&#160;</td>
          <td class="paramname"><em>callee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function&#160;</td>
          <td class="paramname"><em>function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a direct connection from the given emitter object to the given function, using an specific callee object. </p>
<p>Direct connections invoke the destination function just after the source signal is invoked. The destination function is invoked in the same thread the signal was emitted. This connections preserve caller affinity (The sink is invoked only if it was the caller object was who emitted the signal, not whenever any object emits the signal). Direct connections are implemented by registering instances of <a class="el" href="classcpp_1_1_sync_sink.html" title="Implements a direct connection to the destination function. ">SyncSink</a> on the caller object. The destination function has an associated callee object, so this connection could be polled directly from the callee object. If the destination function is a member function of the callee class, the function is invoked using callee. Both source (The member function pointer representing the signal) and function must have the same signature.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">caller</td><td>object the signal is raised from. </td></tr>
    <tr><td class="paramname">Class::*source</td><td>Pointer to the class member function representing the signal. </td></tr>
    <tr><td class="paramname">Callee&amp;</td><td>callee Destination object of the connection. </td></tr>
    <tr><td class="paramname">function</td><td>Function to be invoked when the signal is emitted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to the sink of the connection. </dd></dl>

</div>
</div>
<a class="anchor" id="a154d13b2bcf5f8bbf997b5172284b486"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Caller , typename Function , typename R , typename Class , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt;const <a class="el" href="classcpp_1_1_signal_sink.html">SignalSink</a>&gt; cpp::SignalEmitter::connect_async </td>
          <td>(</td>
          <td class="paramtype">Caller &amp;&#160;</td>
          <td class="paramname"><em>caller</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(Class::*)(Args...)&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function&#160;</td>
          <td class="paramname"><em>function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an asynchronous connection between a signal and a function. </p>
<p>Asynchronous connections are connections that don't directly invoke the destination function when the signal is invoked but delay the invocation until the user explicitly polls the connection. See <a class="el" href="classcpp_1_1_signal_emitter.html#a2c933986daab2d4ce95b3f92adfe0970" title="Polls this object for incomming signal emissions. ">SignalEmitter::poll()</a> and SignalSink::poll(). Async connections are implemented by means of the <a class="el" href="classcpp_1_1_async_sink.html" title="Implements an asynchronous signal sink suited for communication between different threads...">AsyncSink</a> class, which enqueues invocations on a thread-safe queue and deques and invokes the destination function when the connection is polled. <b>Async connections are designed for inter-thread communication</b>, where one thread acts as producer (invokes/emits the signal) and thread other consumes the connection (explicitly polls the connection). Please consider using direct connections by default and use async connections only as a communication bridge between two threads.</p>
<p>The destination function has no associated callee object, so the connection can be polled through the returned sink only. The destination function is executed in the same thread the connection is polled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">caller</td><td>Object the signal is raised from. </td></tr>
    <tr><td class="paramname">Class::*source</td><td>Pointer to the class member representing the signal. </td></tr>
    <tr><td class="paramname">function</td><td>Function to be invoked when the connection is polled (See details).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to the connection sink. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="cmake_2cmake-project_8cpp-example.html#a3">cmake/cmake-project.cpp</a>, and <a class="el" href="signals_2signals_8cpp-example.html#a1">signals/signals.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a74547169c5a7375e9812e966efb2d3fd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Caller , typename Callee , typename Function , typename R , typename Class , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt;const <a class="el" href="classcpp_1_1_signal_sink.html">SignalSink</a>&gt; cpp::SignalEmitter::connect_async </td>
          <td>(</td>
          <td class="paramtype">Caller &amp;&#160;</td>
          <td class="paramname"><em>caller</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(Class::*)(Args...)&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callee &amp;&#160;</td>
          <td class="paramname"><em>callee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function&#160;</td>
          <td class="paramname"><em>function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an asynchronous connection between a signal and a function using an specific callee object. </p>
<p>(For details on async connections in general, see SignalEmitter::connect_async(caller, source, function) details).</p>
<p>This connection has an asociated callee object. <a class="el" href="classcpp_1_1_signal_emitter.html" title="Class that can send and receive signals from other emitters. ">SignalEmitter</a> objects have a <a class="el" href="classcpp_1_1_signal_emitter.html#a2c933986daab2d4ce95b3f92adfe0970" title="Polls this object for incomming signal emissions. ">SignalEmitter::poll()</a> function that polls all the connections comming to it (i.e. all connections which the object is acting as callee). The destination function is executed in the same thread the connection is polled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">caller</td><td>Object the signal is raised from. </td></tr>
    <tr><td class="paramname">Class::*source</td><td>Pointer to the class member representing the signal. </td></tr>
    <tr><td class="paramname">function</td><td>Function to be invoked when the connection is polled (See details).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to the connection sink. </dd></dl>

</div>
</div>
<a class="anchor" id="a037c3bfe62b4cb68df612fd413321e98"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Class , typename R , typename... FArgs, typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void cpp::SignalEmitter::emit </td>
          <td>(</td>
          <td class="paramtype">Class &amp;&#160;</td>
          <td class="paramname"><em>emitter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(Class::*)(FArgs...)&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emits a signal on the given emitter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">emitter</td><td>Object to emit the signal from. </td></tr>
    <tr><td class="paramname">Class::*function</td><td>Function pointer representing the signal. </td></tr>
    <tr><td class="paramname">args</td><td>Signal arguments. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2c933986daab2d4ce95b3f92adfe0970"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cpp::SignalEmitter::poll </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Polls this object for incomming signal emissions. </p>
<p>For all connections coming to this <a class="el" href="classcpp_1_1_signal_emitter.html" title="Class that can send and receive signals from other emitters. ">SignalEmitter</a> object, this method invokes SignalSink::poll() so all pending sygnals are resolved. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/siplasplas/signals/<a class="el" href="emitter_8hpp_source.html">emitter.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>cpp</b></li><li class="navelem"><a class="el" href="classcpp_1_1_signal_emitter.html">SignalEmitter</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
