<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>siplasplas: cpp::BasicSimpleAny&lt; Capacity &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">siplasplas
   </div>
   <div id="projectbrief">A library for C++ reflection and introspection</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classcpp_1_1_basic_simple_any.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classcpp_1_1_basic_simple_any-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">cpp::BasicSimpleAny&lt; Capacity &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__type-erasure.html">Type-erasure</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Implements a non-allocating type-erased value container.  
 <a href="classcpp_1_1_basic_simple_any.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="simpleany_8hpp_source.html">siplasplas/typeerasure/simpleany.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a51140d3630b27ecd66b4c6741a04f0c4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a51140d3630b27ecd66b4c6741a04f0c4"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcpp_1_1_basic_simple_any.html#a51140d3630b27ecd66b4c6741a04f0c4">BasicSimpleAny</a> (const T &amp;value)</td></tr>
<tr class="memdesc:a51140d3630b27ecd66b4c6741a04f0c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an any of type T from an lvalue of type T.  <a href="#a51140d3630b27ecd66b4c6741a04f0c4">More...</a><br /></td></tr>
<tr class="separator:a51140d3630b27ecd66b4c6741a04f0c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc6cf206739af92408a141784b6b1b0c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abc6cf206739af92408a141784b6b1b0c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>BasicSimpleAny</b> (const <a class="el" href="classcpp_1_1_basic_simple_any.html">BasicSimpleAny</a> &amp;other)</td></tr>
<tr class="separator:abc6cf206739af92408a141784b6b1b0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad14feef5af5a5bfd7d493a21dab5a928"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad14feef5af5a5bfd7d493a21dab5a928"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>BasicSimpleAny</b> (<a class="el" href="classcpp_1_1_basic_simple_any.html">BasicSimpleAny</a> &amp;&amp;other)</td></tr>
<tr class="separator:ad14feef5af5a5bfd7d493a21dab5a928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebaab3396a60fab86b1dd80d9161dba2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aebaab3396a60fab86b1dd80d9161dba2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcpp_1_1_basic_simple_any.html#aebaab3396a60fab86b1dd80d9161dba2">hasType</a> () const </td></tr>
<tr class="memdesc:aebaab3396a60fab86b1dd80d9161dba2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the any has a value of type T.  <a href="#aebaab3396a60fab86b1dd80d9161dba2">More...</a><br /></td></tr>
<tr class="separator:aebaab3396a60fab86b1dd80d9161dba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f2b6195c3748fd926ba5b559481e74e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4f2b6195c3748fd926ba5b559481e74e"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcpp_1_1_basic_simple_any.html#a4f2b6195c3748fd926ba5b559481e74e">get</a> () const </td></tr>
<tr class="memdesc:a4f2b6195c3748fd926ba5b559481e74e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a readonly reference to the hosted object.  <a href="#a4f2b6195c3748fd926ba5b559481e74e">More...</a><br /></td></tr>
<tr class="separator:a4f2b6195c3748fd926ba5b559481e74e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8379fab4423c1ec56f75546879bc9673"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8379fab4423c1ec56f75546879bc9673"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcpp_1_1_basic_simple_any.html#a8379fab4423c1ec56f75546879bc9673">get</a> ()</td></tr>
<tr class="memdesc:a8379fab4423c1ec56f75546879bc9673"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a eference to the hosted object.  <a href="#a8379fab4423c1ec56f75546879bc9673">More...</a><br /></td></tr>
<tr class="separator:a8379fab4423c1ec56f75546879bc9673"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22a8ba6a9fc2e19a5e6318eb061a063e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a22a8ba6a9fc2e19a5e6318eb061a063e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcpp_1_1_basic_simple_any.html">BasicSimpleAny</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcpp_1_1_basic_simple_any.html#a22a8ba6a9fc2e19a5e6318eb061a063e">operator=</a> (const T &amp;value)</td></tr>
<tr class="memdesc:a22a8ba6a9fc2e19a5e6318eb061a063e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns a value of type T.  <a href="#a22a8ba6a9fc2e19a5e6318eb061a063e">More...</a><br /></td></tr>
<tr class="separator:a22a8ba6a9fc2e19a5e6318eb061a063e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10fe37e4d57e256428fd9097677576ff"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a10fe37e4d57e256428fd9097677576ff"></a>
<a class="el" href="classcpp_1_1_basic_simple_any.html">BasicSimpleAny</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classcpp_1_1_basic_simple_any.html">BasicSimpleAny</a> &amp;other)</td></tr>
<tr class="separator:a10fe37e4d57e256428fd9097677576ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc0a691ce94236279f9e716d8f3a1dbf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abc0a691ce94236279f9e716d8f3a1dbf"></a>
<a class="el" href="classcpp_1_1_basic_simple_any.html">BasicSimpleAny</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classcpp_1_1_basic_simple_any.html">BasicSimpleAny</a> &amp;&amp;other)</td></tr>
<tr class="separator:abc0a691ce94236279f9e716d8f3a1dbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aca9b54efb6303352b0bcf6d06a61254d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:aca9b54efb6303352b0bcf6d06a61254d"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classcpp_1_1_basic_simple_any.html">BasicSimpleAny</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcpp_1_1_basic_simple_any.html#aca9b54efb6303352b0bcf6d06a61254d">create</a> (Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:aca9b54efb6303352b0bcf6d06a61254d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="classcpp_1_1_basic_simple_any.html" title="Implements a non-allocating type-erased value container. ">BasicSimpleAny</a> with an in-place constructed value of type T.  <a href="#aca9b54efb6303352b0bcf6d06a61254d">More...</a><br /></td></tr>
<tr class="separator:aca9b54efb6303352b0bcf6d06a61254d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac127a89d9e38c876fcde9a4e4d5a20ee"><td class="memTemplParams" colspan="2">template&lt;std::size_t LhsCapacity, std::size_t RhsCapacity&gt; </td></tr>
<tr class="memitem:ac127a89d9e38c876fcde9a4e4d5a20ee"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcpp_1_1_basic_simple_any.html#ac127a89d9e38c876fcde9a4e4d5a20ee">sameType</a> (const <a class="el" href="classcpp_1_1_basic_simple_any.html">BasicSimpleAny</a>&lt; LhsCapacity &gt; &amp;lhs, const <a class="el" href="classcpp_1_1_basic_simple_any.html">BasicSimpleAny</a>&lt; RhsCapacity &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ac127a89d9e38c876fcde9a4e4d5a20ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if two <a class="el" href="classcpp_1_1_basic_simple_any.html" title="Implements a non-allocating type-erased value container. ">BasicSimpleAny</a> objects host values of the same type.  <a href="#ac127a89d9e38c876fcde9a4e4d5a20ee">More...</a><br /></td></tr>
<tr class="separator:ac127a89d9e38c876fcde9a4e4d5a20ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:af8e21647a194e7ab7ac3a10ac5491e00"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af8e21647a194e7ab7ac3a10ac5491e00"></a>
static constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>STORAGE_CAPACITY</b></td></tr>
<tr class="separator:af8e21647a194e7ab7ac3a10ac5491e00"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;std::size_t Capacity&gt;<br />
class cpp::BasicSimpleAny&lt; Capacity &gt;</h3>

<p>Implements a non-allocating type-erased value container. </p>
<p>The template <a class="el" href="classcpp_1_1_basic_simple_any.html" title="Implements a non-allocating type-erased value container. ">BasicSimpleAny</a> implements a type-erased value container, that is, a type that can hold values of different types at runtime. <a class="el" href="classcpp_1_1_basic_simple_any.html" title="Implements a non-allocating type-erased value container. ">BasicSimpleAny</a> uses a fixed-size buffer as storage to avoid dynamic allocations. The maximum capacity of this storage can be controlled with the <code>Capacity</code> template parameter.</p>
<p><a class="el" href="classcpp_1_1_basic_simple_any.html" title="Implements a non-allocating type-erased value container. ">BasicSimpleAny</a> assumes that types hosted on it satisfy the CopyConstructible, MoveConstructible, CopyAssignable, MoveAssignable, and Destructible. If any of those concepts are not satisfied, an exception would be thrown if the corresponding feature is used. This means you can use non-satisfying types as long as the operation is not needed (Invoked). For example:</p>
<div class="fragment"><div class="line"><a class="code" href="classcpp_1_1_basic_simple_any.html">cpp::BasicSimpleAny&lt;64&gt;</a> any{NoCopyAssignable()}: <span class="comment">// Ok, NoCopyAssignable is move constructible</span></div><div class="line"><span class="keyword">auto</span> any2 = <a class="code" href="classcpp_1_1_basic_simple_any.html">cpp::BasicSimpleAny&lt;64&gt;::create</a>&lt;NoCopyAssignable&gt;(); <span class="comment">// Ok, NoCopyAssignable is default constructible</span></div><div class="line">any2 = any; <span class="comment">// EXCEPTION THROWN: NoCopyAssignable is not copy assignable (Noooo, really?)</span></div><div class="line">any2 = std::move(any); <span class="comment">// Ok, NoCopyAssignable is move assignable</span></div></div><!-- fragment --><p>Note this behavior is undefined and may be disabled in release builds. In general, <b>using semantics not supporeted by the hosted type has undefined behavior</b>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Capacity</td><td>Size in bytes of the internal storage. <b>Is not the max type sizeof()</b>, since some storage may be unused to fit with the type alignment </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a51140d3630b27ecd66b4c6741a04f0c4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Capacity&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcpp_1_1_basic_simple_any.html">cpp::BasicSimpleAny</a>&lt; Capacity &gt;::<a class="el" href="classcpp_1_1_basic_simple_any.html">BasicSimpleAny</a> </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an any of type T from an lvalue of type T. </p>
<p>A copy is done from the T lvalue argument to the any storage</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>A value of type T to store in the any </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aca9b54efb6303352b0bcf6d06a61254d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Capacity&gt; </div>
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classcpp_1_1_basic_simple_any.html">BasicSimpleAny</a> <a class="el" href="classcpp_1_1_basic_simple_any.html">cpp::BasicSimpleAny</a>&lt; Capacity &gt;::create </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a <a class="el" href="classcpp_1_1_basic_simple_any.html" title="Implements a non-allocating type-erased value container. ">BasicSimpleAny</a> with an in-place constructed value of type T. </p>
<p>The value is constructed directly on the any storage, no extra copy operations are done. Arguments are passed as-is to the object constructor.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of the value to be constructed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>Constructor arguments</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classcpp_1_1_basic_simple_any.html" title="Implements a non-allocating type-erased value container. ">BasicSimpleAny</a> instance hosting an object of type T </dd></dl>

</div>
</div>
<a class="anchor" id="a4f2b6195c3748fd926ba5b559481e74e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Capacity&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classcpp_1_1_basic_simple_any.html">cpp::BasicSimpleAny</a>&lt; Capacity &gt;::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a readonly reference to the hosted object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of the returned object. If T is different from the hosted object type, the behavior is undefined (See <a class="el" href="classcpp_1_1_basic_simple_any.html#aebaab3396a60fab86b1dd80d9161dba2" title="Checks if the any has a value of type T. ">hasType()</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8379fab4423c1ec56f75546879bc9673"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Capacity&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classcpp_1_1_basic_simple_any.html">cpp::BasicSimpleAny</a>&lt; Capacity &gt;::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a eference to the hosted object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of the returned object. If T is different from the hosted object type, the behavior is undefined (See <a class="el" href="classcpp_1_1_basic_simple_any.html#aebaab3396a60fab86b1dd80d9161dba2" title="Checks if the any has a value of type T. ">hasType()</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aebaab3396a60fab86b1dd80d9161dba2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Capacity&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcpp_1_1_basic_simple_any.html">cpp::BasicSimpleAny</a>&lt; Capacity &gt;::hasType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the any has a value of type T. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the hosted type is <b>exactly</b> T, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a22a8ba6a9fc2e19a5e6318eb061a063e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Capacity&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcpp_1_1_basic_simple_any.html">BasicSimpleAny</a>&amp; <a class="el" href="classcpp_1_1_basic_simple_any.html">cpp::BasicSimpleAny</a>&lt; Capacity &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns a value of type T. </p>
<p>If the current hosted type is T, performs a copy assignment of <code>value</code> into the hosted object. Else, the destructor of the hosted object is invoked and the value is copy-constructed into the storage.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Value to be assigned to the any </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to <code>*this</code> </dd></dl>

</div>
</div>
<a class="anchor" id="ac127a89d9e38c876fcde9a4e4d5a20ee"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Capacity&gt; </div>
<div class="memtemplate">
template&lt;std::size_t LhsCapacity, std::size_t RhsCapacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="classcpp_1_1_basic_simple_any.html">cpp::BasicSimpleAny</a>&lt; Capacity &gt;::sameType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcpp_1_1_basic_simple_any.html">BasicSimpleAny</a>&lt; LhsCapacity &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcpp_1_1_basic_simple_any.html">BasicSimpleAny</a>&lt; RhsCapacity &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if two <a class="el" href="classcpp_1_1_basic_simple_any.html" title="Implements a non-allocating type-erased value container. ">BasicSimpleAny</a> objects host values of the same type. </p>
<dl class="section return"><dt>Returns</dt><dd>True if both hosted types are <b>exactly equal</b> i (i.e. <code>std::is_same&lt;hosted type of lhs, hosted type of rhs&gt;::value</code> would yield true). </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/siplasplas/typeerasure/<a class="el" href="simpleany_8hpp_source.html">simpleany.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>cpp</b></li><li class="navelem"><a class="el" href="classcpp_1_1_basic_simple_any.html">BasicSimpleAny</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
