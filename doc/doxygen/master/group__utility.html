<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>siplasplas: Utility</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">siplasplas
   </div>
   <div id="projectbrief">A library for C++ reflection and introspection</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__utility.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Utility</div>  </div>
</div><!--header-->
<div class="contents">

<p>Some random utilities needed by other siplasplas modules.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__assert"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__assert.html">Assert</a></td></tr>
<tr class="memdesc:group__assert"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assertion utilities. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__dynamic-library"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dynamic-library.html">Dynamic-library</a></td></tr>
<tr class="memdesc:group__dynamic-library"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cross platform API to load symbols from shared librarties at runtime. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__error-handling"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__error-handling.html">Error-handling</a></td></tr>
<tr class="memdesc:group__error-handling"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error handling tools. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__hash"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hash.html">Hash</a></td></tr>
<tr class="memdesc:group__hash"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hashing utilities based on <code>std::hash</code>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__memory-manip"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory-manip.html">Memory-manip</a></td></tr>
<tr class="memdesc:group__memory-manip"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tools related to raw memory manipulation. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpp_1_1_identity.html">cpp::Identity</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A functor class implementing the identity function.  <a href="classcpp_1_1_identity.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpp_1_1_universal_reference.html">cpp::UniversalReference&lt; T, IsLvalueReference, IsConst &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a copyable wrapper of an universal reference.  <a href="classcpp_1_1_universal_reference.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpp_1_1_universal_reference_3_01_01_01_01_01_01_01_01_01_01_01_01_01_01_01_01_01_01_t_00_013d7c84b76fe12a69d69f1a3494ce1211.html">cpp::UniversalReference&lt;                  T,           true,           false &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcpp_1_1_universal_reference.html" title="Implements a copyable wrapper of an universal reference. ">UniversalReference</a> spacialization for non-const lvalues.  <a href="classcpp_1_1_universal_reference_3_01_01_01_01_01_01_01_01_01_01_01_01_01_01_01_01_01_01_t_00_013d7c84b76fe12a69d69f1a3494ce1211.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpp_1_1_universal_reference_3_01_01_01_01_01_01_01_01_01_01_01_01_01_01_01_01_01_01_t_00_01317da0ee22d68a1b11e0bf5e76ec5679.html">cpp::UniversalReference&lt;                  T,           false,           false &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcpp_1_1_universal_reference.html" title="Implements a copyable wrapper of an universal reference. ">UniversalReference</a> spacialization for rvalues.  <a href="classcpp_1_1_universal_reference_3_01_01_01_01_01_01_01_01_01_01_01_01_01_01_01_01_01_01_t_00_01317da0ee22d68a1b11e0bf5e76ec5679.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gaad62b455cf4d9cf038c6652f3081a229"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utility.html#gaad62b455cf4d9cf038c6652f3081a229">SIPLASPLAS_UTILITY_COMPILES</a>(...)                                </td></tr>
<tr class="memdesc:gaad62b455cf4d9cf038c6652f3081a229"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if an expression is well formed.  <a href="#gaad62b455cf4d9cf038c6652f3081a229">More...</a><br /></td></tr>
<tr class="separator:gaad62b455cf4d9cf038c6652f3081a229"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaf4e3666d709fc6add22d09c6ab830469"><td class="memTemplParams" colspan="2">template&lt;typename Expr &gt; </td></tr>
<tr class="memitem:gaf4e3666d709fc6add22d09c6ab830469"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utility.html#gaf4e3666d709fc6add22d09c6ab830469">cpp::compiles</a> (Expr &amp;&amp;expr)</td></tr>
<tr class="memdesc:gaf4e3666d709fc6add22d09c6ab830469"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if an expression is well formed.  <a href="group__utility.html#gaf4e3666d709fc6add22d09c6ab830469">More...</a><br /></td></tr>
<tr class="separator:gaf4e3666d709fc6add22d09c6ab830469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2e9d3829ce1ca89d34621982e21825b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gab2e9d3829ce1ca89d34621982e21825b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utility.html#gab2e9d3829ce1ca89d34621982e21825b">cpp::destroy</a> (T &amp;object)</td></tr>
<tr class="memdesc:gab2e9d3829ce1ca89d34621982e21825b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invokes the destructor of an object.  <a href="group__utility.html#gab2e9d3829ce1ca89d34621982e21825b">More...</a><br /></td></tr>
<tr class="separator:gab2e9d3829ce1ca89d34621982e21825b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa57a939be0ef8e82d9fa9dd6ae3eddca"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaa57a939be0ef8e82d9fa9dd6ae3eddca"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utility.html#gaa57a939be0ef8e82d9fa9dd6ae3eddca">cpp::destroy</a> (T *objectPtr)</td></tr>
<tr class="memdesc:gaa57a939be0ef8e82d9fa9dd6ae3eddca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invokes the destructor of an object.  <a href="group__utility.html#gaa57a939be0ef8e82d9fa9dd6ae3eddca">More...</a><br /></td></tr>
<tr class="separator:gaa57a939be0ef8e82d9fa9dd6ae3eddca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81ebc024fb46c3b4128443a6bf3e2464"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:ga81ebc024fb46c3b4128443a6bf3e2464"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utility.html#ga81ebc024fb46c3b4128443a6bf3e2464">cpp::construct</a> (void *where, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:ga81ebc024fb46c3b4128443a6bf3e2464"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructs an object of type T on the specified address  <a href="group__utility.html#ga81ebc024fb46c3b4128443a6bf3e2464">More...</a><br /></td></tr>
<tr class="separator:ga81ebc024fb46c3b4128443a6bf3e2464"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6eb03b1733484d2450d8a98ff9e793be"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:ga6eb03b1733484d2450d8a98ff9e793be"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utility.html#ga6eb03b1733484d2450d8a98ff9e793be">cpp::construct</a> (T *where, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:ga6eb03b1733484d2450d8a98ff9e793be"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructs an object of type T on the specified address  <a href="group__utility.html#ga6eb03b1733484d2450d8a98ff9e793be">More...</a><br /></td></tr>
<tr class="separator:ga6eb03b1733484d2450d8a98ff9e793be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4744fbb3392aeb77a421cc17243f1af"><td class="memTemplParams" colspan="2"><a class="anchor" id="gaf4744fbb3392aeb77a421cc17243f1af"></a>
template&lt;typename Callable , typename... Args&gt; </td></tr>
<tr class="memitem:gaf4744fbb3392aeb77a421cc17243f1af"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utility.html#gaf4744fbb3392aeb77a421cc17243f1af">cpp::invoke</a> (Callable &amp;&amp;callable, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:gaf4744fbb3392aeb77a421cc17243f1af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invokes the <a href="http://en.cppreference.com/w/cpp/concept/Callable"><code>Callable</code></a> object with the given arguments. See <a href="http://en.cppreference.com/w/cpp/utility/functional/invoke"><code>std::invoke()</code></a> <br /></td></tr>
<tr class="separator:gaf4744fbb3392aeb77a421cc17243f1af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga808e1d5b24e934c1f7638db8a46bb6b7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga808e1d5b24e934c1f7638db8a46bb6b7"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utility.html#ga808e1d5b24e934c1f7638db8a46bb6b7">cpp::lexical_cast</a> (const T &amp;value)</td></tr>
<tr class="memdesc:ga808e1d5b24e934c1f7638db8a46bb6b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an string representation of a value.  <a href="group__utility.html#ga808e1d5b24e934c1f7638db8a46bb6b7">More...</a><br /></td></tr>
<tr class="separator:ga808e1d5b24e934c1f7638db8a46bb6b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga867a648ffab91b5b8948bc80fbac0340"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga867a648ffab91b5b8948bc80fbac0340"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utility.html#ga867a648ffab91b5b8948bc80fbac0340">cpp::lexical_cast</a> (const std::string &amp;value)</td></tr>
<tr class="memdesc:ga867a648ffab91b5b8948bc80fbac0340"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an string representation of a value.  <a href="group__utility.html#ga867a648ffab91b5b8948bc80fbac0340">More...</a><br /></td></tr>
<tr class="separator:ga867a648ffab91b5b8948bc80fbac0340"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga654d1cbd2f4b0fdd4abaf8213893fbd3"><td class="memTemplParams" colspan="2">template&lt;bool Condition, typename ThenBody , typename... Args&gt; </td></tr>
<tr class="memitem:ga654d1cbd2f4b0fdd4abaf8213893fbd3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utility.html#ga654d1cbd2f4b0fdd4abaf8213893fbd3">cpp::staticIf</a> (const ThenBody &amp;thenBody, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:ga654d1cbd2f4b0fdd4abaf8213893fbd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements an static conditional.  <a href="group__utility.html#ga654d1cbd2f4b0fdd4abaf8213893fbd3">More...</a><br /></td></tr>
<tr class="separator:ga654d1cbd2f4b0fdd4abaf8213893fbd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64331d68fc4c2b5be09b1e93bb8aeb2e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga64331d68fc4c2b5be09b1e93bb8aeb2e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utility.html#ga64331d68fc4c2b5be09b1e93bb8aeb2e">cpp::universalReference</a> (T &amp;&amp;value) -&gt; UniversalReference&lt;              std::decay_t&lt; T &gt;,           std::is_lvalue_reference&lt; T &gt;::value,           std::is_const&lt; std::remove_reference_t&lt; T &gt;&gt;::value &gt;</td></tr>
<tr class="memdesc:ga64331d68fc4c2b5be09b1e93bb8aeb2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an universal reference to the given value.  <a href="group__utility.html#ga64331d68fc4c2b5be09b1e93bb8aeb2e">More...</a><br /></td></tr>
<tr class="separator:ga64331d68fc4c2b5be09b1e93bb8aeb2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Some random utilities needed by other siplasplas modules. </p>
<p>The siplaspals-utility module implements various utilities used in the implementation of other siplasplas modules. These utilities are not grouped in any special way, but we encourage the policy of rising utilities into full-fledged modules if these became too complex.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000009">Todo:</a></b></dt><dd><p class="startdd">Move <a class="el" href="meta_8hpp_source.html">meta.hpp</a>, <a class="el" href="function__traits_8hpp_source.html">function_traits.hpp</a>, <a class="el" href="tuple_8hpp_source.html">tuple.hpp</a>, and <a class="el" href="fusion_8hpp_source.html">fusion.hpp</a> to a siplasplas-meta module. </p>
<p>Move <a class="el" href="error__logger_8hpp_source.html">error_logger.hpp</a> and <a class="el" href="exception_8hpp_source.html">exception.hpp</a> to a siplasplas-exception module? </p>
<p class="enddd">Move cpp::Overload&lt;&gt; to <a class="el" href="function__traits_8hpp_source.html">function_traits.hpp</a></p>
</dd></dl>
<p>siplasplas-utility includes the following features:</p>
<ul>
<li><b>Assertion macros</b>: A set of assertion macros based in Google Test syntax. See <a class="el" href="assert_8hpp_source.html">assert.hpp</a>.</li>
<li><b>Clonable pointer</b>: A smart pointer implementing clone semantics. See cloning_ptr.hpp.</li>
<li><b>Dynamic library loading</b>: Cross platform classes to load symbols from shared libraries at runtime. See <a class="el" href="classcpp_1_1_dynamic_library.html" title="Provides a cross-platform interface to load symbols from shared libraries at runtime. ">cpp::DynamicLibrary</a>.</li>
<li><b>Exceptions hierarchy</b>: An exception hierarchy with <a href="https://github.com/fmtlib/fmt">fmt</a> syntax for error messages and automatic logging of exception stack traces. See <a class="el" href="exception_8hpp_source.html">exception.hpp</a>.</li>
<li><b>Function type introspection utilities</b>: Metafunctions to check function types and signatures. See <a class="el" href="function__traits_8hpp_source.html">function_traits.hpp</a>.</li>
<li><b>One header metaprogramming library</b>: A header full of metaprogramming tools. See <a class="el" href="meta_8hpp_source.html">meta.hpp</a>.</li>
<li><b>Overloaded functor factory</b>: See function.hpp.</li>
<li><b>Heterogeneous operations on type and parameter packs</b>: See <a class="el" href="fusion_8hpp_source.html">fusion.hpp</a>.</li>
<li><b>Hash utilities</b>: A <a class="el" href="group__hash.html#ga8b00a3ff97782ab4de57bb04a9c9f6d6" title="Implements a hash function for values of type T. ">cpp::hash()</a> function and equivalent functors that give default hashing for enum types, tuples, function pointer types, etc. See <a class="el" href="hash_8hpp_source.html">hash.hpp</a>.</li>
<li><b>Preprocessor utilities</b>: See <a class="el" href="preprocessor_8hpp_source.html">preprocessor.hpp</a>.</li>
<li><b>String utilities</b>: See <a class="el" href="string_8hpp_source.html">string.hpp</a>.</li>
<li><b>Raw memory manipulation</b>: Tools for raw memory manipulation such as functions to compute aligned addresses, functions to read/write values directly into raw memory, etc. See <a class="el" href="memory__manip_8hpp_source.html">memory_manip.hpp</a>.</li>
<li><b>Tuple manipulation tools</b>: See <a class="el" href="tuple_8hpp_source.html">tuple.hpp</a>. </li>
</ul>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="gaad62b455cf4d9cf038c6652f3081a229"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SIPLASPLAS_UTILITY_COMPILES</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if an expression is well formed. </p>
<p>This macro hides the syntax complexity of <a class="el" href="group__utility.html#gaf4e3666d709fc6add22d09c6ab830469" title="Checks if an expression is well formed. ">cpp::compiles()</a> and checks directly whatever expression is passed as argument to the macro:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;auto result = SIPLASPLAS_UTILITY_COMPILES(</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    identity(std::declval&lt;std::string&gt;()).append(&quot;hello&quot;)</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;static_assert(!result, &quot;std::string has no append() method&quot;);</div></div><!-- fragment --><p>Note there's an implicit <code>identity</code> variable available to delay the evaluation of the expression.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Expression</td><td>to check</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An implementation defined type constexpr-convertible to bool. The returned value converts to true if the expression is well formed, converts to false otherwise. </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gaf4e3666d709fc6add22d09c6ab830469"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Expr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto cpp::compiles </td>
          <td>(</td>
          <td class="paramtype">Expr &amp;&amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if an expression is well formed. </p>
<p>This function takes an expression in the form of an SFINAE-friendly context and checks if the expression can be compiled. For example:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> result = <a class="code" href="group__utility.html#gaf4e3666d709fc6add22d09c6ab830469">cpp::compiles</a>([](<span class="keyword">auto</span> identity) -&gt; decltype(</div><div class="line">    identity(std::declval&lt;std::string&gt;()).append(<span class="stringliteral">&quot;hello&quot;</span>)</div><div class="line">) {});</div><div class="line"></div><div class="line">static_assert(!result, <span class="stringliteral">&quot;std::string has no append() method&quot;</span>);</div></div><!-- fragment --><p>The cpp::compiles(&lt;test&gt;) expression itself is not constexpr, so two steps are needed to perform the constexpr test. <a class="el" href="group__utility.html#gaf4e3666d709fc6add22d09c6ab830469" title="Checks if an expression is well formed. ">cpp::compiles()</a> returns an implementation defined type that is constexpr-convertible to bool, giving the result of the test.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>A callable template of signature <code>decltype(&lt;expression to check&gt;)(<a class="el" href="classcpp_1_1_identity.html" title="A functor class implementing the identity function. ">Identity</a>)</code>. The identity parameter is given to delay the evaluation of the expression, making it dependent of a template of the test. If the expression is directly evaluable, an ill-formed expression would make the program compilation to fail.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An implementation defined type constexpr-convertible to bool. The returned value converts to true if the expression is well formed, converts to false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga81ebc024fb46c3b4128443a6bf3e2464"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cpp::construct </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>constructs an object of type T on the specified address </p>
<p>This function performs an in-place construction of an object of type T in the given address. Arguments are passed as-is to the object constructor. The behavior is undefined if <code>alignment(pointer) != alignof(T)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">where</td><td>Location of the object </td></tr>
    <tr><td class="paramname">args</td><td>Constructor arguments</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line">std::aligned_storage&lt;std::string&gt; storage;</div><div class="line">cpp::construct&lt;std::string&gt;(&amp;storage, <span class="stringliteral">&quot;hello, world!&quot;</span>);</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga6eb03b1733484d2450d8a98ff9e793be"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cpp::construct </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>constructs an object of type T on the specified address </p>
<p>This function performs an in-place construction of an object of type T in the given address. Arguments are passed as-is to the object constructor. The behavior is undefined if <code>alignment(pointer) != alignof(T)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">where</td><td>Location of the object </td></tr>
    <tr><td class="paramname">args</td><td>Constructor arguments</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line">std::aligned_storage&lt;std::string&gt; storage;</div><div class="line">std::string* stringPtr = <span class="keyword">reinterpret_cast&lt;</span>std::string*<span class="keyword">&gt;</span>(&amp;storage);</div><div class="line"></div><div class="line"><a class="code" href="group__utility.html#ga81ebc024fb46c3b4128443a6bf3e2464">cpp::construct</a>(stringPtr, <span class="stringliteral">&quot;hello, world!&quot;</span>);</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="gab2e9d3829ce1ca89d34621982e21825b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cpp::destroy </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>object</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invokes the destructor of an object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Must be Destructible (See std::is_destructible) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa57a939be0ef8e82d9fa9dd6ae3eddca"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cpp::destroy </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>objectPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invokes the destructor of an object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Must be Destructible (See std::is_destructible) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga808e1d5b24e934c1f7638db8a46bb6b7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string cpp::lexical_cast </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an string representation of a value. </p>
<p>This function invokes <code>operator&lt;&lt;(std::ostream&amp;, const T&amp;)</code> to get an string representation of a given value.</p>
<p>It's a simplified version of the <a href="http://www.boost.org/doc/libs/1_55_0/doc/html/boost_lexical_cast.html">Boost.Lexical_Cast library</a>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>value type. Must have a valid <code>operator&lt;&lt;(std::ostream&amp;, T)</code> overload. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Value which is translated to a string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string representation of the given value. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="examples_2reflection_2static_2serialization_8cpp-example.html#a0">examples/reflection/static/serialization.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga867a648ffab91b5b8948bc80fbac0340"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T cpp::lexical_cast </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an string representation of a value. </p>
<p>This function invokes <code>operator&gt;&gt;(std::istream&amp;, T&amp;)</code> to assign a T value from an string representation of it.</p>
<p>It's a simplified version of the <a href="http://www.boost.org/doc/libs/1_55_0/doc/html/boost_lexical_cast.html">Boost.Lexical_Cast library</a>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Required output value type. Must have a valid <code>operator&gt;&gt;(std::istream&amp;, T&amp;)</code> overload. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>String representation of the value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value of type <code>T</code> equivalent to the <code>value</code> string representation argument. </dd></dl>

</div>
</div>
<a class="anchor" id="ga654d1cbd2f4b0fdd4abaf8213893fbd3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Condition, typename ThenBody , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto cpp::staticIf </td>
          <td>(</td>
          <td class="paramtype">const ThenBody &amp;&#160;</td>
          <td class="paramname"><em>thenBody</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements an static conditional. </p>
<p>An static conditional allows to conditionally evaluate some code depending on the value of a compile time property. The body of the conditional is implemented by user provided functions.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keywordtype">void</span> f(T value)</div><div class="line">{</div><div class="line">    cpp::staticIf&lt;std::is_integral&lt;T&gt;::value&gt;([&amp;](<span class="keyword">auto</span> identity)</div><div class="line">    {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;the value is integral\n&quot;</span>;</div><div class="line">    });</div><div class="line"></div><div class="line">    ...</div><div class="line">}</div></div><!-- fragment --><p>The body of the untaken conditional path shall not be evaluated by the compiler and can contain ill formed code. <b>NOTE</b>: This behavior relies on the two phase template processing scheme, so the statement above is only true for entities that will be evaluated in the instantiation phase only:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keywordtype">void</span> foo(T value)</div><div class="line">{</div><div class="line">   <span class="keywordtype">int</span> i = 0;</div><div class="line"></div><div class="line">   <span class="comment">// The condition is false, so the code</span></div><div class="line">   <span class="comment">// inside the if &quot;should&quot; not be evaluated:</span></div><div class="line">   cpp::staticIf&lt;false&gt;([&amp;](<span class="keyword">auto</span> identity)</div><div class="line">   {</div><div class="line">       <span class="comment">// Ok: value depends on T template parameter.</span></div><div class="line">       value.TheMostBizarreMethodName();</div><div class="line"></div><div class="line">       <span class="comment">// ERROR: &#39;int&#39; type is not class/struct/union.</span></div><div class="line">       i.method();</div><div class="line"></div><div class="line">       <span class="comment">// Ok: identity(i) depends on a template parameter.</span></div><div class="line">       identity(i).method();</div><div class="line">   });</div><div class="line">}</div></div><!-- fragment --><p>As the example shows, the conditional body takes an <code>identity</code> parameter that can be used to force the evaluation of an expression at the second phase.</p>
<p>The static conditional expression also provides an <code>else</code> sentence in the form of an <code>Else()</code> method:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keywordtype">void</span> foo(T value)</div><div class="line">{</div><div class="line">   <span class="keywordtype">int</span> i = 0;</div><div class="line"></div><div class="line">   cpp::staticIf&lt;false&gt;([&amp;](<span class="keyword">auto</span> identity)</div><div class="line">   {</div><div class="line">       value.TheMostBizarreMethodName();</div><div class="line">       i.method();</div><div class="line">       identity(i).method();</div><div class="line">   }).Else([&amp;](<span class="keyword">auto</span> identity)</div><div class="line">   {</div><div class="line">       std::cout &lt;&lt; i &lt;&lt; std::endl;</div><div class="line">   });</div><div class="line">}</div></div><!-- fragment --><p><a class="el" href="group__utility.html#ga654d1cbd2f4b0fdd4abaf8213893fbd3" title="Implements an static conditional. ">cpp::staticIf()</a> supports returning values from the conditional body too:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line">T twice(<span class="keyword">const</span> T&amp; value)</div><div class="line">{</div><div class="line">    <span class="keywordflow">return</span> cpp::staticIf&lt;std::is_class&lt;T&gt;::value&gt;([&amp;](<span class="keyword">auto</span>)</div><div class="line">    {</div><div class="line">        <span class="keywordflow">return</span> value.twice();</div><div class="line">    }).Else([&amp;](<span class="keyword">auto</span>)</div><div class="line">    {</div><div class="line">        <span class="keywordflow">return</span> value * 2;</div><div class="line">    });</div><div class="line">}</div></div><!-- fragment --><p>note this has some caveats:</p>
<ul>
<li><b>Return types cannot be inferred</b>: Due to technical reasons <code>auto</code> or any other kind of type inference cannot be used with the return value of a static conditional.</li>
<li><b>Return may not be optimal in some code paths</b>: If the condition is true, the <code>then</code> path is picked. If the <code>then</code> body returns a value, such value is not returned directly (So elligible for RVO) but bypassed through the <code>else</code> internals. This means <b>returning a value from a positive conditional may involve two move operations</b>.</li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Condition</td><td>Value of the condition. The value should be evaluable at compile time, else compilation fails. </td></tr>
    <tr><td class="paramname">ThenBody</td><td>Function type with one template-dependent value parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thenBody</td><td>Body of the <code>then</code> path of the conditional. Evaluated only if the condition is true. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An unspecified type implementing the <code>else</code> part of the conditional. </dd></dl>

</div>
</div>
<a class="anchor" id="ga64331d68fc4c2b5be09b1e93bb8aeb2e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto cpp::universalReference </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classcpp_1_1_universal_reference.html">UniversalReference</a>&lt;
    std::decay_t&lt;T&gt;,
    std::is_lvalue_reference&lt;T&gt;::value,
    std::is_const&lt;std::remove_reference_t&lt;T&gt;&gt;::value
&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an universal reference to the given value. </p>
<p>This function checks the value category of the given value and instances the apropiate <a class="el" href="classcpp_1_1_universal_reference.html" title="Implements a copyable wrapper of an universal reference. ">cpp::UniversalReference</a> specialization. Note the returned type depends on the value category. For an alternative with common a type, see cpp::typeerasure::AnyArg</p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classcpp_1_1_universal_reference.html" title="Implements a copyable wrapper of an universal reference. ">UniversalReference</a> specialization instance as follows:<ul>
<li><code><a class="el" href="classcpp_1_1_universal_reference.html" title="Implements a copyable wrapper of an universal reference. ">UniversalReference</a>&lt;std::decay_t&lt;T&gt;, true, true&gt;</code> if <code>value</code> type is deduced to a const reference to an lvalue.</li>
<li><code><a class="el" href="classcpp_1_1_universal_reference.html" title="Implements a copyable wrapper of an universal reference. ">UniversalReference</a>&lt;std::decay_t&lt;T&gt;, true, false&gt;</code> if <code>value</code> type is deduced to a non const reference to an lvalue.</li>
<li><code><a class="el" href="classcpp_1_1_universal_reference.html" title="Implements a copyable wrapper of an universal reference. ">UniversalReference</a>&lt;std::decay_t&lt;T&gt;, false, false&gt;</code> if <code>value</code> type is deduced to an rvalue reference </li>
</ul>
</dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
