#ifndef SIPLASPLAS_REFLECTION_STATIC_API_HPP
#define SIPLASPLAS_REFLECTION_STATIC_API_HPP

/**
 * \ingroup reflection
 * \defgroup static-reflection
 * \brief Access to static reflection information
 *
 * This API gives access to the reflection metadata collected by
 * DRLParser at compile time.
 * The APi works by declaring a template for each kind of entity supported
 * by the reflection engine (`Class`, `Enum`, `Field`, etc) in the namespace
 * `cpp::static_reflection`. These templates expect the entity to be reflected as
 * parameter (The class type, the enum type, the member function pointer, etc), with
 * the instance having access to the metadata of the given entity:
 *
 * ``` cpp
 * using ClassReflectionInfo = cpp::static_reflection::Class<MyCustomClass>;
 * using EnumReflectionInfo  = cpp::static_reflection::Enum<MyEnum>;
 * using MethodReflectionInfo = cpp::static_reflection::Function<decltype(&MyCustomClass::method), &MyCustomClass::method>;
 * ...
 * ```
 *
 * For the specifics about the metadata returned for the different kinds of entities,
 * see the templates declared in the cpp::static_reflection namespace.
 *
 * ## How the API namespaces are organized
 *
 * The static reflection API reads the metadata scanned by DRLParser. This metadata is
 * represented (stored) as instances of the different templates of the `cpp::static_reflection::meta`
 * namespace.
 *
 * That metadata is not declared nor accessed directly by the API but the code generated by
 * DRLParser declares specializations of `cpp::static_reflection::codegen` templates that contain
 * the metadata (the `cpp::static_reflection::meta` instances). This codegen templates are specialized
 * for each type found in the processed header (So the parameters are supposed to be unique, an "index" to
 * the metadata).
 *
 * The static reflection API (`cpp::static_reflection` templates) indexes metadata
 * through the `cpp::static_reflection::codegen` templates.
 *
 *
 * ### TL;DR:
 *  - **`cpp::static_reflection::meta`**: Datatypes representing reflection metadata
 *  - **`cpp::static_reflection::codegen`**: Indexation of metadata generated during reflection parsing and
 *  processing (DRLParser)
 *  - **`cpp::static_reflection`**: API for static access of reflection metadata
 *
 * ### Why `codegen` middle layer?
 *
 * The `codegen` namespace is designed to abstract the reflection metadata representation from
 * the user API, so the backend can be changed to use other reflection methods. Currently,
 * all the metadata access is directly implemented in `meta`, but `codegen` can be used as a
 * translation layer if the metadata backend changes.
 *
 * \example examples/reflection/static/serialization.cpp
 * \example examples/reflection/static/enum.cpp
 * \example examples/reflection/static/chaiscript.cpp
 */

#include "sourceinfo.hpp"
#include "function.hpp"
#include "field.hpp"
#include "class.hpp"
#include "enum.hpp"

#include <siplasplas/reflection/common/annotations.hpp>

namespace cpp
{

namespace srfl = static_reflection;

}

#endif // SIPLASPLAS_REFLECTION_STATIC_API_HPP
